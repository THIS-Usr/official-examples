# 16. Candy Store with External Gumball Machine Blueprint

Blueprints and components do not exist on the radix network in isolation. They
are addressable and can interact with each other if allowed. This example shows
us how to allow and enable component interactions other than transactions.

- [External Blueprints](#external-blueprints)
- [Multiple instantiation functions](#multiple-instantiation-functions)
- [Using the Candy Store with an External Gumball Machine](#using-the-candy-store-with-an-external-gumball-machine)
  - [Setup with no published external blueprint](#setup-with-no-published-external-blueprint)
  - [Setup including publishing an external blueprint](#setup-including-publishing-an-external-blueprint)
  - [Usage](#usage)

## External Blueprints

As the Radix ecosystem continues to mature there will be more and more
blueprints available to use. These blueprints are created by many different
teams and individuals and some will be intended for external use, with the
possibility of [royalties](https://docs.radixdlt.com/docs/using-royalties) given
to the blueprint owner. You may work on some of these yourself.

[Using external blueprints](https://docs.radixdlt.com/docs/cross-blueprint-calls#calling-a-specific-blueprint-or-global-component-of-your-package)
is a little different to using your own. We need to import the external
blueprint into our own using the `extern_blueprint!` macro. This macro describes
the external blueprint with its address, name, function and method signatures.

```rs
mod candy_store {
    extern_blueprint! {
        // import the GumballMachine package from the ledger using its package address
     "<YOUR_GUMBALL_MACHINE_PACKAGE_ADDRESS>",
        GumballMachine {
            // Blueprint Functions
            fn instantiate_global(price: Decimal) -> ( Global<GumballMachine>, Bucket);
            fn instantiate_owned(price: Decimal, component_address: ComponentAddress) -> Owned<GumballMachine>;

            // Component Methods
            fn get_status(&self) -> Status;
            fn buy_gumball(&mut self, payment: Bucket) -> (Bucket, Bucket);
            fn set_price(&mut self, price: Decimal);
            fn withdraw_earnings(&mut self) -> Bucket;
            fn refill_gumball_machine(&mut self);
        }
    }
```

When publishing the package, the package address is checked for an existing
blueprint. Publishing will fail if none exists.

The description in the macro gives us access to the external blueprint's
functions in our own. In our Candy Store blueprint we use this to instantiate a
component from a separately published Gumball Machine package.

```rs
    let gumball_machine =
        Blueprint::<GumballMachine>::instantiate_owned(gumball_price, component_address);
```

This then gives us access to the Gumball Machine's methods.

Note the `Blueprint::<GumballMachine>` type. This is generated by the
`extern_blueprint!` macro. The syntax is a little odd if you have not worked
with Rust before, but is hopefully clear.

## Multiple instantiation functions

So as to allow for both an owned and global gumball machine, we have two
instantiation functions. `instantiate_owned`:

```rs
    pub fn instantiate_owned(
        price: Decimal,
        component_address: ComponentAddress,
    ) -> Owned<GumballMachine> {
        // --snip--
        .instantiate()
    }
```

And `instantiate_global`:

```rs
    pub fn instantiate_global(price: Decimal) -> (Global<GumballMachine>, Bucket) {
    // --snip--
    let gumball_machine = Self::instantiate_owned(price, component_address)
            // assign the component owner role to the possessor of the owner_badge resource
            .prepare_to_globalize(OwnerRole::Fixed(rule!(require(
                owner_badge.resource_address()
            ))))
            // apply the address reservation
            .with_address(address_reservation)
            .globalize();

        (gumball_machine, owner_badge)
    }
```

This is a good demonstration of component instantiation producing owned
components initially, which can subsequently be globalized. `instantiate_global`
calls `instantiate_owned` then globalizes the returned component.

We use it here, so the same version of the blueprint can be used in this and the
next example.

Having multiple instantiation functions can serve several other purposes as
well. Allowing for a standard default component to be created, while also
allowing for a more complex or customized component versions, potentially using
input arguments to decide on metadata or
[more complex access rules](https://docs.radixdlt.com/docs/en/reusable-blueprints-pattern#multiple-instantiation-functions).

## Using the Candy Store with an External Gumball Machine

You will notice that there are two packages in this example. To demonstrate
using and external blueprint we need to first publish the external Gumball
Machine package to the ledger. The Candy Store Package can then be published
using the Gumball Machine package address.

Before we try that though, lets see what happens without a published Gumball
Machine package.

### Setup with no published external blueprint

1.  First, clone the repository if you have not done so, and then change
    directory to this example.

    ```
    git clone https://github.com/radixdlt/official-examples.git

    cd official-examples/step-by-step/16-candy-store-external-blueprint
    ```

2.  Next reset the simulator and create a new account.

    ```sh
    resim reset
    resim new-account
    ```

3.  Try to publish the Candy Store package to the ledger.

    ```sh
    resim publish ./2-candy-store
    ```

    You will see an error message like this:

    ```sh
    Error: TransactionRejected(ErrorBeforeLoanAndDeferredCostsRepaid(KernelError(InvalidReference(NodeId("0da38df56782eb2eab703ee4022b250aec726b06abd9504d23b2266c0556")))))
    ```

    This is because the Candy Store blueprint is trying to find the Gumball
    Machine blueprint, but the Gumball Machine blueprint does not exist on the
    ledger at the given address yet.

### Setup including publishing an external blueprint

1.  From the example's directory, run the setup script.

    On Linux or macOS:

    ```sh
    cd 16-candy-store-external-blueprint/
    source ./setup.sh
    ```

    On Windows:

    ```cmd
    cd 16-candy-store-external-blueprint/
    ./setup.bat
    ```

    This will reset the simulator, build the Gumball Machine package, publish it
    to the simulator and export several useful values.

2.  Add the Gumball Machine package address to the `2-candy-store/src/lib.rs`
    file, in the `extern_blueprint!` macro.

    ```rust
    extern_blueprint! {
     "<YOUR_GUMBALL_MACHINE_PACKAGE_ADDRESS>",
     // --snip--
    }
    ```

3.  Publish the Candy Store package to the simulator.

    ```sh
    resim publish ./2-candy-store
    ```

4.  Export the Candy Store package address.

    ```sh
    export package2=<YOUR_CANDY_STORE_PACKAGE_ADDRESS>
    ```

5.  Instantiate the Candy Store by using the `instantiate_candy_store.rtm`
    manifest.

    ```sh
    resim run manifests/instantiate_candy_store.rtm
    ```

6.  Export the component and owner badge addresses. These will be displayed in
    the output of the previous command. To check the addresses use
    `resim show <ADDRESS>`. The badge can also be found with its name when
    inspecting the default account (`resim show $account`).

    ```sh
    export component=<YOUR_COMPONENT_ADDRESS>
    export component_badge=<YOUR_OWNER_BADGE_ADDRESS>
    ```

### Usage

The Candy Store component can now be used in the same way as in previous
examples. There are manifest files in the `manifests/` directory usable with the
`resim run <PATH_TO_MANIFEST>` command.

You might also like to try publishing the packages to the Stokenet test network
to see how they work there. This process is described for a single package in
the [Ledger Ready Gumball Machine](../08-ledger-ready-gumball-machine/README.md)
example. Simply do this for both, remembering to insert the Gumball Machine
package address into the Candy Store package before publishing it. The
transaction manifests in the `manifests/` directory can then be used to interact
with the components on Stokenet, though you will have to update the addresses in
them.
